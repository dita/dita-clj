# Task & Pipeline

## ExtensibleAntInvoker : a dita-ot extension of ant class Task

In build scripts (e.g. `plugins/org.dita.base/build_preprocess.xml`),
the `<pipeline ...>` element is used to specify dita tasks; for
example, the first preprocessing task, `gen-list` is defined as follows:

    <target name="gen-list" depends="" unless="preprocess.gen-list.skip" description="Generate file list">
      <pipeline message="Generate list." taskname="gen-list" inputmap="${args.input}" tempdir="${dita.temp.dir}">
        <module class="org.dita.dost.module.GenMapAndTopicListModule">
          <param name="inputdir" location="${args.input.dir}" if="args.input.dir"/>
		  ...
        </module>
      <pipeline/>
    <target/>

_**CAVEAT**_ `plugins/org.dita.base/build_preprocess.xml` is generated
by the build process, so you will not find it in the github source
tree.  It is generated from
[plugins/org.dita.base/build_preprocess_template.xml](https://github.com/dita-ot/dita-ot/blob/develop/src/main/plugins/org.dita.base/build_preprocess_template.xml),
which is in the github source tree.

The `<pipeline ...>` element is mapped to class
 [ExtensibleAntInvoker](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/invoker/ExtensibleAntInvoker.java),
 which extends
 [org.apache.tools.ant.Task](https://ant.apache.org/manual/develop.html).
 Leaving aside various adminitrative and bookkeeping methods, the
 central method of the `Task` class is `execute`, which takes no args
 and returns void.

**In other words**, an Ant task is like a "thunk"; a generic object that
  "wraps" application-specific code that is invoked indirectly via
  `execute`.

The mapping is specified in `plugins/org.dita.base/build_init.xml`:

    <taskdef name="pipeline"
        classname="org.dita.dost.invoker.ExtensibleAntInvoker">
        <classpath refid="dost.jar.path" />
    </taskdef>


### Details of ExtensibleAntInvoker

File:  `src/main/java/org/dita/dost/invoker/ExtensibleAntInvoker.java`

Package:  `org.dita.dost.invoker`

Class:

    ExtensibleAntInvoker
	    constructor:  null constructor only ExtensibleAntInvoker()
	    contains (private final):
		    pipeline 		:: PipelineFacade  (see below for details on pipeline stuff)
			pipelineParams	:: ArrayList of Param objs (Param is a nested class, see below)
			modules			:: ArrayList of Module objs (Module is a nested class, see below)
			attrs			:: HashMap of string pairs
			tempDir			:: File

**pipelineParams** These seem to be <param ...> nested directly under
  <pipeline...>, which in fact do not occur, at least not in

    plugins/org.dita.base/build_preprocess.xml

etc.

#### Nested Elements, Embedded classes

We have three parallel hierarchies:

**XML:**  the `<pipeline ...>` element may contain embedded `<module ...>`
elements, which may contain embedded `<param ...>` elements.

**Class:**  Parallel to the XML hierarchy, class `ExtensibleAntInvoker` defines three
nested classes:

* `ExtensibleAntInvoker$Module` - represents task implemented in Java
* `ExtensibleAntInvoker$Xslt` - extends Module; represents tasks implemented via XSLT stylesheets
* `ExtensibleAntInvoker$Param` - parameters passed to Module and Xslt objects

**Object:**  The object hierarchy follows the same pattern:

* `ExtensibleAntInvoker` objects contain a list of
 * `ExtensibleAntInvoker$Module` objects, each of which contains a list of
   * `ExtensibleAntInvoker$Param` objects


### Module Details

    Module - determined by <module ...> embedded in <pipeline...>
	    contains:
	        ArrayList of Param objs
		    Class, set by @class of <module class="...">


ExtensibleAntInvoker.execute() ::
/** Nested modules. */
private final ArrayList<Module> modules;

Modules are generated by embedded `<module ...>` elements.  By
mandatory convention, embedded element names correspond to nested
class names (Capitalized).  Ant creates and initializes objects of the
nested class (=embedded element) as ExtensibleAntInvoker$Module
(embedded class) objects.  It then calls
ExtensibleAntInvoker.addConfiguredModule(m) to add Module m to the
modules ArrayList of the ExtensibleAntInvoker object.

Embedded `<module ...>` elements may have embedded `<param ...>`
elements.  These too correspond to an embedded class
`ExtensibleAntInvoker$Param`.  So Ant creates Param objects p, sets
the attr names and vals by calling the `set<foo>` methods on the Param
object, and passes it to the containing Module by calling its
`addConfiguredParam(final Param p)` method.  The Module adds the Param
to its params ArrayList

Note that this is controlled by naming conventions.  Element names
correspond to embedded class names (upcase), attrib names correspond
to `set<attrib-name>` methods, and embedded elements trigger calls to
the `addConfigured<Embedded-class>` method of the embedding Element
class.

The net effect is that the XML structure

    <foo ...><bar ...><param .../></bar></foo>

defines object composition: foo objects contain bar objects which
contain param objects.

So this mechanism implements object composition: "modules" become
components of a task, which is responsible for `running` them.  When
all the bookkeeping etc. has been completed, the `execute()` method of
the task is run.  Since the application-specific code is in the class
that is *contained* in the Module object (the Module object is
_**not**_ application-specific code; it does not inherit from the app
code, nor vice-versa, as you might expect), the implementation of
`execute` is reponsible for running the app-specific code.

In other words, `<pipeline ...>` (and so `ExtensibleAntInvoker`) is a
kind of job control function.  (That's why we're dumping it; the
combination of Clojure and leiningen makes all of this vastly
simpler.)

### Module Class

The above account doesn't say how the (job-control) Module manages to
run the application-specific code.  Recall the structure of the
"gen-list" operation:

    <target name="gen-list" depends="" unless="preprocess.gen-list.skip" description="Generate file list">
      <pipeline message="Generate list." taskname="gen-list" inputmap="${args.input}" tempdir="${dita.temp.dir}">
        <module class="org.dita.dost.module.GenMapAndTopicListModule">
          <param name="inputdir" location="${args.input.dir}" if="args.input.dir"/>
		  ...
        </module>
      <pipeline/>
    <target/>

The application-specific code is in
`org.dita.dost.module.GenMapAndTopicListModule`.  The Module created
by Ant processing will contain a reference to this Class, which it
will send to a factory method in order to create an object.

Now, ordinarily you might think that the params get passed to the
GenMapAndTopicListModule object as initialization arguments, or
perhaps using setters; but that's not the way this works.  Instead,
these params get installed into a "pipelineHashIO" object (named
pipelineInput), which is really just a holder of params with get/set
methods.  The life-cycle is more like this: use a (zero param) factory
method to create a GenMapAndTopicListModule object; create a
pipelineHashIO object; install the params into the latter;
finally, invoke the `execute` method of the GenMapAndTopicListModule,
passing the pipelineHashIO object as a parameter.

org.dita.dost.module.ModuleFactory

PipelineFacade.execute(moduleClass, input pipeline)

final AbstractPipelineModule module = factory.createModule(moduleClass);

            return moduleClass.newInstance();


### PipelineInput, etc




### Details of Pipeline package
