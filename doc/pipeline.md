# Task & Pipeline

## ExtensibleAntInvoker : a dita-ot extension of ant class Task

In build scripts (e.g. `plugins/org.dita.base/build_preprocess.xml`),
the `<pipeline ...>` element is used to specify dita tasks; for
example, the first preprocessing task, `gen-list` is defined as follows:

    <target name="gen-list" depends="" unless="preprocess.gen-list.skip" description="Generate file list">
      <pipeline message="Generate list." taskname="gen-list" inputmap="${args.input}" tempdir="${dita.temp.dir}">
        <module class="org.dita.dost.module.GenMapAndTopicListModule">
          <param name="inputdir" location="${args.input.dir}" if="args.input.dir"/>
		  ...
        </module>
      <pipeline/>
    <target/>

_**CAVEAT**_ `plugins/org.dita.base/build_preprocess.xml` is generated
by the build process, so you will not find it in the github source
tree.  It is generated from
[plugins/org.dita.base/build_preprocess_template.xml](https://github.com/dita-ot/dita-ot/blob/develop/src/main/plugins/org.dita.base/build_preprocess_template.xml),
which is in the github source tree.

The `<pipeline ...>` element is mapped to class
 [ExtensibleAntInvoker](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/invoker/ExtensibleAntInvoker.java),
 which extends
 [org.apache.tools.ant.Task](https://ant.apache.org/manual/develop.html).
 Leaving aside various adminitrative and bookkeeping methods, the
 central method of the `Task` class is `execute`, which takes no args
 and returns void.

**In other words**, an Ant task is like a "thunk"; a generic object that
  "wraps" application-specific code that is invoked indirectly via
  `execute`.

The mapping is specified in `plugins/org.dita.base/build_init.xml`:

    <taskdef name="pipeline"
        classname="org.dita.dost.invoker.ExtensibleAntInvoker">
        <classpath refid="dost.jar.path" />
    </taskdef>


### Details of ExtensibleAntInvoker

File:  `src/main/java/org/dita/dost/invoker/ExtensibleAntInvoker.java`

Package:  `org.dita.dost.invoker`

Class:

    ExtensibleAntInvoker
	    constructor:  null constructor only ExtensibleAntInvoker()
	    contains (private final):
		    pipeline 		:: PipelineFacade  (see below for details on pipeline stuff)
			pipelineParams	:: ArrayList of Param objs (Param is a nested class, see below)
			modules			:: ArrayList of Module objs (Module is a nested class, see below)
			attrs			:: HashMap of string pairs
			tempDir			:: File

**pipelineParams** These seem to be <param ...> nested directly under
  <pipeline...>, which in fact do not occur, at least not in

    plugins/org.dita.base/build_preprocess.xml

etc.

#### Nested Elements, Embedded classes

We have three parallel hierarchies:

**XML:**  the `<pipeline ...>` element may contain embedded `<module ...>`
elements, which may contain embedded `<param ...>` elements.

**Class:**  Parallel to the XML hierarchy, class `ExtensibleAntInvoker` defines three
nested classes:

* `ExtensibleAntInvoker$Module` - represents task implemented in Java
  * `ExtensibleAntInvoker$Xslt` - extends Module; represents tasks implemented via XSLT stylesheets
* `ExtensibleAntInvoker$Param` - parameters passed to Module and Xslt objects

**Object:**  The object hierarchy follows the same pattern:

* `ExtensibleAntInvoker` objects contain a list of
 * `ExtensibleAntInvoker$Module` objects, each of which contains a list of
   * `ExtensibleAntInvoker$Param` objects


### ExtensibleAntInvoker$Module

    Module - determined by <module ...> embedded in <pipeline...>
	    contains:
	        params :: **public** ArrayList of Param objs
		    cls :: <? extends AbstractPipelineModule>; private, set by @class attrib

Each ExtensibleAntInvoker$Module represents an `org.dita.dost.module`;
in other words, each and (task) module represents an application
module -- the one named in the @class attribute of the `<module ...>`
element.  (See below on the two kinds of module.)

Modules are generated by embedded `<module ...>` elements.  By
mandatory convention, embedded element names correspond to nested
class names (Capitalized).  Ant creates and initializes objects of the
nested class (=embedded element) as ExtensibleAntInvoker$Module
(embedded class) objects.  It then calls
ExtensibleAntInvoker.addConfiguredModule(m) to add Module m to the
modules ArrayList of the ExtensibleAntInvoker object.

Embedded `<module ...>` elements may have embedded `<param ...>`
elements.  These too correspond to an embedded class
`ExtensibleAntInvoker$Param`.  So Ant creates Param objects p, sets
the attr names and vals by calling the `set<foo>` methods on the Param
object, and passes it to the containing Module by calling its
`addConfiguredParam(final Param p)` method.  The Module adds the Param
to its params ArrayList

Note that this is controlled by naming conventions.  Element names
correspond to embedded class names (upcase), attrib names correspond
to `set<attrib-name>` methods, and embedded elements trigger calls to
the `addConfigured<Embedded-class>` method of the embedding Element
class.

The net effect is that the XML structure

    <foo ...><bar ...><param .../></bar></foo>

defines object composition: foo objects contain bar objects which
contain param objects.

So this mechanism implements object composition: "modules" become
components of a task, which is responsible for `running` them.  When
all the bookkeeping etc. has been completed, the `execute()` method of
the task is run.  Since the application-specific code is in the class
that is *contained* in the Module object (the Module object is
_**not**_ application-specific code; it does not inherit from the app
code, nor vice-versa, as you might expect), the implementation of
`execute` is reponsible for running the app-specific code.

In other words, `<pipeline ...>` (and so `ExtensibleAntInvoker`) is a
kind of job control function.  (That's why we're dumping it; the
combination of Clojure and leiningen makes all of this vastly
simpler.)

### Module Class

The above account doesn't say how the (job-control) Module manages to
run the application-specific code.  Recall the structure of the
"gen-list" operation:

    <target name="gen-list" depends="" unless="preprocess.gen-list.skip" description="Generate file list">
      <pipeline message="Generate list." taskname="gen-list" inputmap="${args.input}" tempdir="${dita.temp.dir}">
        <module class="org.dita.dost.module.GenMapAndTopicListModule">
          <param name="inputdir" location="${args.input.dir}" if="args.input.dir"/>
		  ...
        </module>
      <pipeline/>
    <target/>

The application-specific code is in
`org.dita.dost.module.GenMapAndTopicListModule`.  The Module created
by Ant processing will contain a reference to this Class, which it
will send to a factory method in order to create an object.

Now, ordinarily you might think that the params get passed to the
GenMapAndTopicListModule object as initialization arguments, or
perhaps using setters; but that's not the way this works.  Instead,
these params get installed into a "pipelineHashIO" object (named
pipelineInput), which is really just a holder of params with get/set
methods.

The life-cycle is more like this:

* use a [factory](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/ModuleFactory.java) method to create a Module (e.g. [GenMapAndTopicListModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/GenMapAndTopicListModule.java)) object using its nullary constructor;
* create a [pipelineHashIO](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/pipeline/PipelineHashIO.java) object;
* install the params into the latter;
* finally, invoke the `execute` method of the Module, passing the pipelineHashIO object as a parameter.

**CAVEAT** There are _two_ notions of "module" at work here.  One the
  one hand, we have the embedded class ExtensibleAntInvoker$Module,
  which implements the `<module ...>` dita/ant task.  On the other
  hand, we have "DITA-OT Modules", which are _**not**_ ant tasks.  And
  we also have the pipeline "facade" classes, which support the same
  "execute, setLogger, setJob" protocol as the modules, but are not
  themselves modules (see below).

The basic idea is that the "task modules" contain pipelines, which
contain (and manage) "dita-ot modules", which implement application
(i.e. dita) code.

DITA-OT Modules have the following structure in the
  `org.dita.dost.module` package (namespace):

* [AbstractPipelineModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/AbstractPipelineModule.java) :: public interface
        protocol:
		    setLogger :: DITAOTLogger -> void
			setJob  :: Job -> void
		    execute :: AbstractPipelineInput -> AbstractPipelineOutput
  * [AbstractPipelineModuleImpl](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/AbstractPipelineModuleImpl.java) :: public abstract class 
        same protocol:  setLogger, setJob, and execute
    * [ChunkModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/ChunkModule.java)
    * [CoderefModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/CoderefModule.java)
	* [ConrefPushModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/ConrefPushModule.java)
	* [DebugAndFilterModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/DebugAndFilterModule.java)
	* [EscapeUnicodeModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/EscapeUnicodeModule.java)
	* [FilterModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/FilterModule.java)
	* [GenMapAndTopicListDebugAndFilterModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/GenMapAndTopicListDebugAndFilterModule.java)
	* [GenMapAndTopicListModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/GenMapAndTopicListModule.java)
	* [ImageMetadataModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/ImageMetadataModule.java)
	* [IndexTermExtractModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/IndexTermExtractModule.java)
	* [KeyrefModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/KeyrefModule.java)
	* [MoveIndexModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/MoveIndexModule.java)
	* [MoveLinksModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/MoveLinksModule.java)
	* [MoveMetaModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/MoveMetaModule.java)
	* [TopicFragmentModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/TopicFragmentModule.java)
	* [TopicMergeModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/TopicMergeModule.java)
	* [XsltModule](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/module/XsltModule.java)


### ModuleFactory

`org.dita.dost.module.ModuleFactory` is a singleton class; it has two
create methods:

    public AbstractPipelineModule createModule(final String moduleName)
	    return (AbstractPipelineModule) Class.forName(module).newInstance();

    public AbstractPipelineModule createModule(final Class<? extends AbstractPipelineModule> moduleClass)
            return moduleClass.newInstance();

### Pipelines

To complement the `org.dita.dost.module.module` classes listed above,
we have some "pipeline" classes in the ` org.dita.dost.pipeline`
package.

**Note** that the facade classes have the same protocol as the classes in
  `org.dita.dost.module`: execute, setLogger, and setJob methods.

* [AbstractFacade](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/pipeline/AbstractFacade.java) interface; methods:
      execute : String x AbstractPipelineInput -> AbstractPipelineOutput
	  execute : Class<? extends AbstractPipelineModule> x AbstractPipelineInput -> AbstractPipelineOutput
      execute : AbstractPipelineModule x AbstractPipelineInput  -> AbstractPipelineOutput
      setLogger :: DITAOTLogger -> void
      setJob  ::  Job -> void
  * [PipelineFacade](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/pipeline/PipelineFacade.java) implements AbstractFacade; the **execute** methods create and execute `org.dita.dost.module` objects
* [AbstractPipelineInput](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/pipeline/AbstractPipelineInput.java) interface, methods:
      setAttribute : String x String -> void
	  getAttribute : String -> String
  * [PipelineHashIO](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/pipeline/PipelineHashIO.java) implements AbstractPipelineInput
* [AbstractPipelineOutput](https://github.com/dita-ot/dita-ot/blob/develop/src/main/java/org/dita/dost/pipeline/AbstractPipelineOutput.java)  **not implemented**


PipelineFacade.execute(moduleClass, input pipeline)

final AbstractPipelineModule module = factory.createModule(moduleClass);

            return moduleClass.newInstance();




### Details of Pipeline package
